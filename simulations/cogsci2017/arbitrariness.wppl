// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

var utterances = ['word1', 'word2'];
var objects = ['circle', 'square'];
var meanings = ['circle', 'square'];
var numMeanings = meanings.length;

var params = {
  speakerAlpha : argv.speakerAlpha,
  listenerAlpha: argv.listenerAlpha,
  discountFactor: argv.discountFactor,
  guessingEpsilon: argv.guessingEpsilon,
  costWeight: 1,
  coord: 'diff',
  numTrials: 40,
  utterances: utterances,
  objects: objects
};

var pragStr = ('discount:' + params.discountFactor);
// var posttestF = csv.open('./output/arbitrariness_meaningTest_' + pragStr + '_' + argv.gameNum + '.csv');
// csv.writeLine('gameNum,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,' +
//               'trialNum,agentID,word,circleScore,squareScore', posttestF);

console.log(params);

var lexicalPrior = Infer({method: 'enumerate'}, function() {
  return _.zipObject(utterances, map(function(utt) {
    return sample(Categorical({vs: meanings}));
  }, utterances))
});

var postTest = function(iterationNum, trial, outputFile, posterior1, posterior2) {
  var shared = [
    iterationNum, params.speakerAlpha, params.listenerAlpha, params.discountFactor,
    params.guessingEpsilon, trial.trialNum
  ];

  map(function(word) {
    var speaker1TopGuess = marginalize(posterior1, function(x) {return x[word]});
    var speaker2TopGuess = marginalize(posterior2, function(x) {return x[word]});
    csv.writeLine(shared.concat([
      trial.speakerID, word, speaker1TopGuess.score('circle'), speaker1TopGuess.score('square')
    ]).join(','), outputFile);
    csv.writeLine(shared.concat([
      trial.listenerID, word, speaker2TopGuess.score('circle'), speaker2TopGuess.score('square')
    ]).join(','), outputFile);
  }, utterances);
};

// for each point in data, we want the model's predictions 
var iterate = function(iterationNum, outputFile, dataSoFar) {
  var trialNum = dataSoFar[1].length;
  var currTrial = {
    intendedName: uniformDraw(objects),
    context : objects,
    trialNum: trialNum,
    speakerID: (trialNum % 2) == 0 ? 1 : 2,
    listenerID: (trialNum % 2) == 0 ? 2 : 1
  };

  var config = extend(params, {context: currTrial.context});
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, config);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, config);

  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, config);
  var topSpeakerChoice =  sample(speakerOutput);

  var listenerOutput = L(topSpeakerChoice, listenerPosterior, config);
  var topListenerChoice =  sample(listenerOutput);

  //postTest(iterationNum, currTrial, posttestF, speakerPosterior, listenerPosterior);
  // display('speaker distribution')
  // display(speakerOutput);
  // display('listener distribution')
  // display(listenerOutput)
  //console.log(topSpeakerChoice)
  // console.log(topListenerChoice);
  //display('correct? ' + (topListenerChoice == currTrial.intendedName));
  csv.writeLine([iterationNum, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.guessingEpsilon,
                 currTrial.trialNum, currTrial.speakerID, currTrial.listenerID, currTrial.intendedName,
                 topSpeakerChoice, topListenerChoice,
                 topListenerChoice == currTrial.intendedName
                ].join(','), outputFile);

  var newDataSoFar = _.zipObject([currTrial.speakerID, currTrial.listenerID], map(function(id) {
    return dataSoFar[id].concat(extend(currTrial, {
      role : id == currTrial.speakerID ? 'speaker' : 'listener',
      wordID : topSpeakerChoice,
      clickedName : topListenerChoice
    }));
  }, [currTrial.speakerID, currTrial.listenerID]));

  if(currTrial.trialNum < params.numTrials) {
    iterate(iterationNum, outputFile, newDataSoFar);
  } 
};

var f = csv.open('./output/arbitrariness_trajectory_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,trialNum,speakerID,listenerID,' +
              'intendedName,topSpeakerChoice,topListenerChoice,correct',
              f);
map(function(i) {
  iterate(i, f, {1: [], 2: []});
}, _.range(1000));
csv.close(f);

//console.log('running posttest')
//postTest('post', posttestF);
//csv.close(posttestF);
