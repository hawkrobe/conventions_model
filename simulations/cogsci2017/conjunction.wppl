// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

var unconstrainedUtterances = ['word1', 'word2', 'word3', 'word4'];
var derivedUtterances = ['word1_word2', 'word1_word3','word1_word4',
                         'word2_word3','word2_word4','word3_word4'];
var utterances = unconstrainedUtterances.concat(derivedUtterances);
var objects = ['blue_circle', 'red_square'];
var meanings = ['blue_circle', 'red_square'];
var numMeanings = meanings.length;

var params = {
  speakerAlpha : argv.speakerAlpha,
  listenerAlpha: argv.listenerAlpha,
  discountFactor: argv.discountFactor,
  costWeight: argv.costWeight,  
  guessingEpsilon: argv.guessingEpsilon,
  numTrials: 10,
  context: objects,
  utterances: utterances,
  objects: objects
};

var pragStr = ('discount:' + params.discountFactor);
var posttestF = csv.open('./output/conjunction_meaningTest_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,speakerAlpha,listenerAlpha,discountFactor,costWeight,guessingEpsilon,trialNum,agentID,word1_cost,word1_inform,word2_cost,word2_inform,word1word2_cost,word1word2_inform,word1_production,word2_production,word1word2_production,word1_belief,word2_belief,word3_belief,word4_belief', posttestF);

console.log(params);

var lexicalPrior = Infer({method: 'enumerate'}, function() {
  return _.zipObject(unconstrainedUtterances, map(function(utt) {
    var bias = 0.05;
    var preferredMeaning = (utt == 'word1' || utt == 'word2' ? 'blue_circle' : 'red_square');
    var ps = map(function(meaning) {return meaning == preferredMeaning ? 1/2 + bias : 1/2 - bias;}, meanings);
    return sample(Categorical({vs: meanings, ps: ps}));
  }, unconstrainedUtterances));
});

var postTest = function(iterationNum, trial, outputFile, posterior1, posterior2) {
  var word1Meaning = marginalize(posterior1, function(x) {return x['word1']});
  var word2Meaning = marginalize(posterior1, function(x) {return x['word2']});
  var word3Meaning = marginalize(posterior1, function(x) {return x['word3']});
  var word4Meaning = marginalize(posterior1, function(x) {return x['word4']});
  csv.writeLine([
    iterationNum, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.costWeight, params.guessingEpsilon,
    trial.trialNum, trial.speakerID,
    params.costWeight * getUttCost('word1'),
    params.speakerAlpha * expectation(posterior1, function(lexicon) {
      var config = extend(params, {lexicon: lexicon});
      return L0('word1', config).score('blue_circle');
    }),
    params.costWeight * getUttCost('word2'),
    params.speakerAlpha * expectation(posterior1, function(lexicon) {
      var config = extend(params, {lexicon: lexicon});
      return L0('word2', config).score('blue_circle');
    }),
    params.costWeight * getUttCost('word1_word2'),      
    params.speakerAlpha * expectation(posterior1, function(lexicon) {
      var config = extend(params, {lexicon: lexicon});
      return L0('word1_word2', config).score('blue_circle');
    }),
    S('blue_circle', posterior1,params).score('word1'),
    S('blue_circle', posterior1,params).score('word2'),
    S('blue_circle', posterior1,params).score('word1_word2'),        
    word1Meaning.score('blue_circle'),
    word2Meaning.score('blue_circle'),
    word3Meaning.score('blue_circle'),
    word4Meaning.score('blue_circle')
  ].join(','), outputFile);
};

// for each point in data, we want the model's predictions 
var iterate = function(iterationNum, outputFile, dataSoFar) {
  var trialNum = dataSoFar[1].length;
  var currTrial = {
    intendedName: uniformDraw(objects),
    context : objects,
    trialNum: trialNum,
    repNum: Math.floor(trialNum / 2),
    speakerID: (trialNum % 2) == 0 ? 1 : 2,
    listenerID: (trialNum % 2) == 0 ? 2 : 1
  };

  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);

  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, params);
  var topSpeakerChoice =  sample(speakerOutput);

  // var listenerOutput = L(topSpeakerChoice, listenerPosterior, params);
  var topListenerChoice = currTrial.intendedName// sample(listenerOutput);
  //console.log(JSON.stringify(speakerOutput));
  // console.log(expectation(speakerPosterior, function(lexicon) {
  //   var config = extend(params, {lexicon: lexicon});
  //   return L0('word1_word2', config).score('blue_circle');
  // })),
  console.log(topSpeakerChoice);
  postTest(iterationNum, currTrial, posttestF, speakerPosterior, listenerPosterior);
  csv.writeLine([iterationNum, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.costWeight,
                 params.guessingEpsilon, currTrial.trialNum, currTrial.speakerID, currTrial.listenerID,
                 currTrial.intendedName, topSpeakerChoice, topListenerChoice,
                 topListenerChoice == currTrial.intendedName
                ].join(','), outputFile);

  var newDataSoFar = _.zipObject([currTrial.speakerID, currTrial.listenerID], map(function(id) {
    return dataSoFar[id].concat(extend(currTrial, {
      role : id == currTrial.speakerID ? 'speaker' : 'listener',
      wordID : topSpeakerChoice,
      clickedName : topListenerChoice
    }));
  }, [currTrial.speakerID, currTrial.listenerID]));

  if(currTrial.trialNum < params.numTrials) {
    iterate(iterationNum, outputFile, newDataSoFar);
  } 
};

var f = csv.open('./output/conjunction_trajectory_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,speakerAlpha,listenerAlpha,discountFactor,costWeight,guessingEpsilon,trialNum,' +
              'speakerID,listenerID,intendedName,topSpeakerChoice,topListenerChoice,correct',
              f);
map(function(i) {
  console.log('iteration', i)
  iterate(i, f, {1: [], 2: []});
}, _.range(1000));
csv.close(f);
csv.close(posttestF);
