// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv

var unconstrainedUtterances = ['word1', 'word2', 'word3', 'word4'];
var derivedUtterances = ['word1_word2', 'word3_word4']; // 'word1_word3','word1_word4',
//'word2_word3','word2_word4',
var utterances = unconstrainedUtterances.concat(derivedUtterances);
var objects = ['bluecircle', 'redsquare'];
var meanings = ['bluecircle', 'redsquare'];
var numMeanings = meanings.length;

var params = {
  speakerAlpha : argv.speakerAlpha,
  listenerAlpha: argv.listenerAlpha,
  discountFactor: argv.discountFactor,
  costWeight: argv.costWeight,
  guessingEpsilon: argv.guessingEpsilon,
  model: argv.model,
  numTrials: 14,
  context: objects,
  utterances: utterances,
  objects: objects,
  inferOptions: {method: 'MCMC', samples:5000, burn:10000, lag:30, verbose:true}
};

console.log(params);

var sampleProbs = function(utt) {
  var bias = utt == 'word1' || utt == 'word2' ? [.5, 1.5] : [1.5,.5];
  var hyperConcentration = Vector(bias);
  var hyperScale = exponential({a: 1});
  return T.mul(hyperConcentration, hyperScale);
};

var sampleLexicon = function(utt, popProbs, partnerProbs) {
  // no pooling model; sample new params for every partner
  // complete pooling model: use same popProbs across all partners
  // partial pooling model: use partnerProbs, sampled from shared hyperParams
  if(params.model == 'no_pooling') {
    return categorical({vs: meanings, ps: dirichlet(sampleProbs(utt))});
  } else if (params.model == 'complete_pooling') {
    return categorical({vs: meanings, ps: popProbs});
  } else if (params.model == 'hierarchical') {
    return categorical({vs: meanings, ps: partnerProbs});
  } else {
    console.error("uh oh, model not recognized" + params.model);
  }
}

var lexicalPrior = function() {
  var lexicons = map(function(utt) {
    var hyperParams = sampleProbs(utt);
    var popProbs = dirichlet(hyperParams);
    // console.log('P(meaning0)', utt, T.get(hyperParams, 0), T.get(popProbs, 0));
    // console.log('P(meaning1)', utt, T.get(hyperParams, 1), T.get(popProbs, 1));     
    return map(function(partnerID) {
      var partnerProbs = dirichlet(hyperParams);
      return sampleLexicon(utt, popProbs, partnerProbs);
    }, [1,2,3,4]);
  }, unconstrainedUtterances);

  // have to invert this to make the formatting work...
  return _.zipObject([1,2,3,4], map(function(partnerID) {
    return _.zipObject(unconstrainedUtterances, map(function(utt_i) {
      return lexicons[utt_i][partnerID];
    }, _.range(unconstrainedUtterances.length)));
  }, _.range(lexicons.length)));
};

// for each point in data, we want the model's predictions 
var iterate = function(outputFile, remainingTrials, dataSoFar) {
  var currTrial = extend(first(remainingTrials), {
    context : objects,
  });
  // run VI on current data
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);
  console.log(marginalize(speakerPosterior, function(v) {return v['1']['word3']}));
  console.log(marginalize(speakerPosterior, function(v) {return v['2']['word3']}));  
  console.log(marginalize(speakerPosterior, function(v) {return v['3']['word3']}));
  console.log(marginalize(speakerPosterior, function(v) {return v['4']['word3']}));

  // get marginal prediction of next data point over lexicon posterior
  var trialParams = extend(params, {partnerID: currTrial.partnerID});
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, trialParams);
  console.log(speakerOutput);
  var nextUtt = sample(speakerOutput);

  var listenerOutput = L(nextUtt, listenerPosterior, trialParams);
  console.log(listenerOutput);
  var nextChoice = sample(listenerOutput);
  
  console.log('chosen utt for partner ' + currTrial.partnerID + ' is: ' + nextUtt);
  console.log('chosen object for partner ' + currTrial.partnerID + ' is: ' + nextChoice);
  console.log('intended: ' + currTrial.intendedName);
  console.log('correct: ' + (nextChoice == currTrial.intendedName));    
  csv.writeLine([argv.model, argv.chainNum, params.alpha, params.costWeight, currTrial.trialNum,
                 currTrial.speakerID, currTrial.listenerID, currTrial.partnerID,
                 nextUtt, speakerOutput.score('word1_word2'),
                 speakerOutput.score('word1'), nextChoice, listenerOutput.score('object1')].join(','), outputFile);

  var newDataSoFar = _.zipObject(_.range(1, 5), map(function(id) {
    var trialPacket = extend(currTrial, {
      role: id == currTrial.speakerID ? "speaker" : "listener",
      wordID: nextUtt,
      clickedName: nextChoice
    });
    return (id == currTrial.speakerID || id == currTrial.listenerID ?
            dataSoFar[id].concat(trialPacket) : dataSoFar[id]);
  }, _.range(1, 5)));

  if(!_.isEmpty(rest(remainingTrials))) {
    iterate(outputFile, rest(remainingTrials), newDataSoFar);
  }
};

var trials = [
  {trialNum: 1, speakerID: 1, listenerID: 2, partnerID: 1, intendedName: 'bluecircle'},
  {trialNum: 2, speakerID: 1, listenerID: 2, partnerID: 1, intendedName: 'redsquare'},
  {trialNum: 3, speakerID: 2, listenerID: 1, partnerID: 1, intendedName: 'bluecircle'},
  {trialNum: 4, speakerID: 2, listenerID: 1, partnerID: 1, intendedName: 'redsquare'},
  {trialNum: 5, speakerID: 1, listenerID: 2, partnerID: 1, intendedName: 'redsquare'},
  {trialNum: 6, speakerID: 1, listenerID: 2, partnerID: 1, intendedName: 'bluecircle'},
  {trialNum: 7, speakerID: 2, listenerID: 1, partnerID: 1, intendedName: 'bluecircle'},
  {trialNum: 8, speakerID: 2, listenerID: 1, partnerID: 1, intendedName: 'redsquare'},
  // {trialNum: 1, speakerID: 3, listenerID: 4, partnerID: 1, intendedName: 'bluecircle'},
  // {trialNum: 2, speakerID: 4, listenerID: 3, partnerID: 1, intendedName: 'bluecircle'},
  // {trialNum: 3, speakerID: 3, listenerID: 4, partnerID: 1, intendedName: 'bluecircle'},
  // {trialNum: 4, speakerID: 4, listenerID: 3, partnerID: 1, intendedName: 'bluecircle'},
  {trialNum: 9, speakerID: 1, listenerID: 3, partnerID: 2, intendedName: 'redsquare'},
  {trialNum: 10, speakerID: 1, listenerID: 3, partnerID: 2, intendedName: 'bluecircle'},
  {trialNum: 11, speakerID: 3, listenerID: 1, partnerID: 2, intendedName: 'bluecircle'},
  {trialNum: 12, speakerID: 3, listenerID: 1, partnerID: 2, intendedName: 'redsquare'},
  {trialNum: 13, speakerID: 1, listenerID: 3, partnerID: 2, intendedName: 'bluecircle'},
  {trialNum: 14, speakerID: 1, listenerID: 3, partnerID: 2, intendedName: 'redsquare'},
  {trialNum: 15, speakerID: 3, listenerID: 1, partnerID: 2, intendedName: 'bluecircle'},
  {trialNum: 16, speakerID: 3, listenerID: 1, partnerID: 2, intendedName: 'redsquare'},
  // {trialNum: 5, speakerID: 2, listenerID: 4, partnerID: 2, intendedName: 'bluecircle'},
  // {trialNum: 6, speakerID: 4, listenerID: 2, partnerID: 2, intendedName: 'bluecircle'},
  // {trialNum: 7, speakerID: 2, listenerID: 4, partnerID: 2, intendedName: 'bluecircle'},
  // {trialNum: 8, speakerID: 4, listenerID: 2, partnerID: 2, intendedName: 'bluecircle'},
  {trialNum: 17, speakerID: 1, listenerID: 4, partnerID: 3, intendedName: 'bluecircle'},
  {trialNum: 18, speakerID: 1, listenerID: 4, partnerID: 3, intendedName: 'redsquare'},
  {trialNum: 19, speakerID: 4, listenerID: 1, partnerID: 3, intendedName: 'bluecircle'},
  {trialNum: 20, speakerID: 4, listenerID: 1, partnerID: 3, intendedName: 'redsquare'},
  {trialNum: 21, speakerID: 1, listenerID: 4, partnerID: 3, intendedName: 'redsquare'},
  {trialNum: 22, speakerID: 1, listenerID: 4, partnerID: 3, intendedName: 'bluecircle'},
  {trialNum: 23, speakerID: 4, listenerID: 1, partnerID: 3, intendedName: 'redsquare'},
  {trialNum: 24, speakerID: 4, listenerID: 1, partnerID: 3, intendedName: 'bluecircle'},
  // {trialNum: 9, speakerID: 2, listenerID: 3, partnerID: 3, intendedName: 'bluecircle'},
  // {trialNum: 10, speakerID: 3, listenerID: 2, partnerID: 3, intendedName: 'bluecircle'},
  // {trialNum: 11, speakerID: 2, listenerID: 3, partnerID: 3, intendedName: 'bluecircle'},
  // {trialNum: 12, speakerID: 3, listenerID: 2, partnerID: 3, intendedName: 'bluecircle'}
];

var f = csv.open('./output/networkOutput' + argv.model + argv.chainNum + '.csv');
csv.writeLine('model,chainNum,alpha,costWeight,time,speakerID,listenerID,partnerID,utt,longUttScore,word1Score,objectPicked,bluecircleScore',f);
iterate(f, trials, {1: [], 2: [], 3: [], 4: []});
csv.close(f);
