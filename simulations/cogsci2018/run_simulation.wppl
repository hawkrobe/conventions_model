// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

var data = refModule.readCSV('input/' + argv.gameNum + '.csv');
var numUtterances = 8;
var utterances = map(function(i) {return 'word' + i;}, _.range(1, numUtterances+1));
var objects = ['circle_striped_highstriped', 'circle_striped_lowstriped',
               'circle_spotted_highspotted', 'circle_spotted_lowspotted',
               'square_red_lightred', 'square_red_darkred',
               'square_blue_lightblue', 'square_blue_darkblue'];
var meanings = ['circle', 'striped', 'spotted', 
                'highstriped', 'lowstriped', 'lowspotted', 'highspotted',
                'square', 'red', 'blue',
                'lightred', 'lightblue', 'darkred', 'darkblue'];
var objectLookup = {
  'redSquare1' : 'square_red_lightred', 'redSquare2' : 'square_red_darkred',
  'blueSquare1' : 'square_blue_lightblue', 'blueSquare2' : 'square_blue_darkblue',
  'stripedCircle1' : 'circle_striped_lowstriped', 'stripedCircle2' :'circle_striped_highstriped',
  'spottedCircle1' : 'circle_spotted_lowspotted', 'spottedCircle2' : 'circle_spotted_highspotted'
};
var numMeanings = meanings.length;
var lexDims = [1];

var params = {
  alpha : 3,
  listenerAlpha: 3,
  coord: argv.coord,
  discountFactor: argv.discountFactor,
  usingPragmatics: argv.usingPragmatics == undefined ? true : argv.usingPragmatics == 'true',
  costWeight: 0,
  utterances: utterances,
  objects: objects
};

var pragStr = (params.usingPragmatics ? 'prag' : 'no_prag') + '_discount' + params.discountFactor + '_' + params.coord;
var posttestF = csv.open('./output/meaningTest_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,agentID,object,word,val', posttestF);

console.log(params);
console.log(lexDims);
var tensorSoftplus = function(x) {
  return T.log(T.add(T.exp(x), 1));
};

var sampleLexicon = function() {
  var out = _.zipObject(utterances, map(function(utt) {
    var meaning = sample(Categorical({
      vs: meanings
    }))
    return meaning
  }, utterances))
  return out
};

var S = function(object, context, posterior) {
  return Infer({method: "enumerate"}, function() {
    var utt = uniformDraw(params.utterances);
    var utility = L(utt, context, posterior).score(object);
    display(utt);
    display(utility);
    factor(params.alpha * utility);
    return utt;
  });
};

var L = function(utt, context, posterior) {
  return Infer({method: "enumerate"}, function() {
    var object = uniformDraw(context);
    var utility = expectation(posterior, function(lexicon) {
      var config = {lexicon: lexicon, context: context};
      var truthTerm = refModule.getLexiconElement(utt, object, extend(params,config));
      // console.log(lexicon)
      // console.log(truthTerm)
      return (params.usingPragmatics ? 
              truthTerm + refModule.getSpeakerScore(utt, object, extend(params, config)) :
	      truthTerm);
    });
    factor(params.listenerAlpha * utility);
    return object;
  });
};

var postTest = function(trial, outputFile, posterior1, posterior2) {
    map(function(word) {
      var speaker1TopGuess = JSON.stringify(marginalize(posterior1, function(x) {return x[word]}))
      var speaker2TopGuess = JSON.stringify(marginalize(posterior2, function(x) {return x[word]}))
      console.log(word)
      console.log(speaker1TopGuess)
      csv.writeLine([argv.gameNum, params.alpha, trial.trialNum, trial.speakerID, word, speaker1TopGuess].join(','), outputFile);
      csv.writeLine([argv.gameNum, params.alpha, trial.trialNum, trial.listenerID, word, speaker2TopGuess].join(','), outputFile);
    }, utterances);
};

var updatePosterior = function(dataSoFar) {
  var data = dataSoFar.slice(-16)
  return Infer({method: 'MCMC', samples:5000,burn:5000,lag:5, model : function() {
    var lexicon = sampleLexicon();

    // impose principle of contrast in prior (only consider lexica where words have non-overlapping meanings)
    condition(_.uniq(_.values(lexicon)).length == _.keys(lexicon).length);
    mapData({data: data}, function(trial) { 
      var discount = Math.pow(params.discountFactor,  dataSoFar.length - trial.trialNum);
      var config = {lexicon: lexicon, context: trial.context};
      var objectToUse = params.coord == 'same' ? trial.intendedName : (trial.role == 'speaker' ? trial.clickedName : trial.intendedName);
      var truthTerm = refModule.getLexiconElement(trial.wordID, objectToUse, extend(params,config));
      // console.log(lexicon)
      // console.log(objectToUse)
      // console.log(trial.wordID)
      // console.log(truthTerm)
      if(params.usingPragmatics){
        var pragmaticTerm = (trial.role == 'speaker' ?
                             refModule.getListenerScore(objectToUse, trial.wordID, extend(params, config)) :
                             refModule.getSpeakerScore(trial.wordID, objectToUse, extend(params, config)));
        // console.log('prag', pragmaticTerm)
        // console.log('truth', truthTerm)
        factor(discount * (truthTerm + pragmaticTerm));
      } else {
        factor(discount * truthTerm);
      }
    });
    return lexicon;
  }});
};

// for each point in data, we want the model's predictions 
var iterate = function(outputFile, remainingTrials, dataSoFar) {
  var currTrialRaw = first(remainingTrials);
  var currTrial = extend(currTrialRaw, {
        context : map(function(v) {return objectLookup[v];},
         [currTrialRaw.object1name, currTrialRaw.object2name,
          currTrialRaw.object3name, currTrialRaw.object4name]),
    intendedName : objectLookup[currTrialRaw['intendedName']]
  });

  console.log(currTrial);
  // run VI on current data
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID]);
//  console.log(JSON.stringify(speakerPosterior))
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID]);
//  console.log(JSON.stringify(listenerPosterior))  
  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, currTrial.context, speakerPosterior);
  var topSpeakerChoice =  sample(speakerOutput)// MAP(speakerOutput)['val']; //

  var listenerOutput = L(topSpeakerChoice, currTrial.context, listenerPosterior);
  var topListenerChoice =  sample(listenerOutput)  // MAP(listenerOutput)['val'];//

  postTest(currTrial, posttestF, speakerPosterior, listenerPosterior);
  display('context is ' + currTrial.context);
  display('top speaker choice is ' + topSpeakerChoice);
  display('top listener choice is ' + topListenerChoice);
  display('intended: ' + currTrial.intendedName);
  display('correct? ' + (topListenerChoice == currTrial.intendedName));
  csv.writeLine([argv.gameNum, params.alpha, params.discountFactor,
                 currTrial.trialNum, currTrial.condition, currTrial.contextType,
                 currTrial.speakerID, currTrial.listenerID,
                 currTrial.intendedName,
                 topSpeakerChoice, topListenerChoice,
                 topListenerChoice == currTrial.intendedName
                ].join(','), outputFile);

  var newDataSoFar = _.zipObject([currTrial.speakerID, currTrial.listenerID], map(function(id) {
    return dataSoFar[id].concat(extend(currTrial, {
      role : id == currTrial.speakerID ? 'speaker' : 'listener',
      wordID : topSpeakerChoice,
      clickedName : topListenerChoice
    }));
  }, [currTrial.speakerID, currTrial.listenerID]));

  if(!_.isEmpty(rest(remainingTrials))) {
    iterate(outputFile, rest(remainingTrials), newDataSoFar);
  } 
};

var f = csv.open('./output/trajectory_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,discountFactor,time,condition,contextType,speakerID,listenerID,' +
              'intendedName,topSpeakerChoice,topListenerChoice,correct',
              f);
iterate(f, data, {1: [], 2: []});
csv.close(f);

console.log('running posttest')
//postTest('post', posttestF);
csv.close(posttestF);
