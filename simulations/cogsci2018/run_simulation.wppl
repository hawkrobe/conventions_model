// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

var data = refModule.readCSV('input/' + argv.gameNum + '.csv');
var numUtterances = 8;
var utterances = map(function(i) {return 'word' + i;}, _.range(1, numUtterances+1));
var objects = ['circle_striped_highstriped', 'circle_striped_lowstriped',
               'circle_spotted_highspotted', 'circle_spotted_lowspotted',
               'square_red_lightred', 'square_red_darkred',
               'square_blue_lightblue', 'square_blue_darkblue'];
var features = ['circle', 'square', 'red', 'blue', 'striped', 'spotted', 
                'highstriped', 'lowstriped', 'lowspotted', 'highspotted', 
                'lightred', 'lightblue', 'darkred', 'darkblue'];
var objectLookup = {
  'redSquare1' : 'square_red_lightred', 'redSquare2' : 'square_red_darkred',
  'blueSquare1' : 'square_blue_lightblue', 'blueSquare2' : 'square_blue_darkblue',
  'stripedCircle1' : 'circle_striped_lowstriped', 'stripedCircle2' :'circle_striped_highstriped',
  'spottedCircle1' : 'circle_spotted_lowspotted', 'spottedCircle2' : 'circle_spotted_highspotted'
};
var numFeatures = features.length;
var lexDims = [numUtterances, numFeatures];

var params = {
  alpha : 5,
  listenerAlpha: 10,
  usingPragmatics: argv.usingPragmatics == undefined ? true : argv.usingPragmatics == 'true',
  costWeight: 0,
  utterances: utterances,
  objects: objects,
  features: features
};

var posttestF = csv.open('./testing_' +argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,agentID,object,word,val',
              posttestF);

console.log(params);
console.log(lexDims);
var tensorSoftplus = function(x) {
  return T.log(T.add(T.exp(x), 1));
};

var partnerGuide = function(paramName) {
  return function() {
    return DiagCovGaussian({
      mu: param({name: 'mu' + paramName, dims: lexDims}),
      sigma: tensorSoftplus(param({name: 'sigma' + paramName, dims: lexDims}))
    });
  };
};

var sampleLexicon = function(agentID) {
  return sample(DiagCovGaussian({mu: zeros(lexDims), sigma: T.mul(ones(lexDims), 5)}),
		{guide: partnerGuide(agentID)});
};

var S = function(object, agentID, context) {
  return Infer({method: "enumerate"}, function() {
    var utt = uniformDraw(params.utterances);

    var distractors = remove(object, context);
    // var utility = expectation(Infer({method:"forward", samples: 100000, guide:true}, function(){
    //   var lexicon = sampleLexicon(agentID);
    //   var config = {lexicon: lexicon, context: context};
    //   return refModule.getL0Score(object, utt, extend(params, config));
    // }));

    //     var utility2 = expectation(Infer({method:"forward", samples: 100000, guide:true}, function(){
    //   var lexicon = sampleLexicon(agentID);
    //   var config = {lexicon: lexicon, context: context};
    //   return (params.usingPragmatics ?
    //           refModule.getL0Score(distractors[0], utt, extend(params, config)):
    //           refModule.getLexiconElement(utt, distractors[0], extend(params, config)));
    // }));
    // var utility3 = expectation(Infer({method:"forward", samples: 100000, guide:true}, function(){
    //   var lexicon = sampleLexicon(agentID);
    //   var config = {lexicon: lexicon, context: context};
    //   return (params.usingPragmatics ?
    //           refModule.getL0Score(distractors[1], utt, extend(params, config)) :
    //           refModule.getLexiconElement(utt, distractors[1], extend(params, config)));
    // }));
    // var utility4 = expectation(Infer({method:"forward", samples: 100000, guide:true}, function(){
    //   var lexicon = sampleLexicon(agentID);
    //   var config = {lexicon: lexicon, context: context};
    //   return (params.usingPragmatics ?
    //           refModule.getL0Score(distractors[2], utt, extend(params, config)):
    //           refModule.getLexiconElement(utt, distractors[2], extend(params, config)));
    // }));
    var listenerOut = L(utt, agentID, context);
    var utility = listenerOut.score(object);
    display(utt)
//    display(JSON.stringify(L(utt, agentID, context)))
    display(utility);
    // display('P' + distractors[0] + utility2);
    // display('P' + distractors[1] + utility3);
    // display('P' + distractors[2] + utility4);
    //display('P_diff: ' + utility_diff);            
    factor(params.alpha * utility);
    return utt;
  });
};

var L = function(utt, agentID, context) {
  return Infer({method: "enumerate"}, function() {
    var object = uniformDraw(context);
    var utility = expectation(Infer({method:"forward", samples: 50000, guide:true}, function(){
      var lexicon = sampleLexicon(agentID);
      var config = {lexicon: lexicon, context: context};
      return (params.usingPragmatics ? 
              Math.exp(refModule.getSpeakerScore(utt, object, extend(params, config))) :
	      Math.exp(refModule.getLexiconElement(utt, object, extend(params, config))));
    }));
    display(object);
    display(utility);
    factor(params.listenerAlpha * Math.log(utility));
    return object;
  });
};

var postTest = function(trialNum, outputFile) {
  map(function(object) {
    map(function(word) {
      var speaker1AvgVal = expectation(Infer({method:"forward", samples: 5000, guide:true}, function(){
        var lexicon = sampleLexicon(1);
        return refModule.getLexiconElement(word, object, extend(params, {lexicon: lexicon}));
      }));
      var speaker2AvgVal = expectation(Infer({method:"forward", samples: 5000, guide:true}, function(){
        var lexicon = sampleLexicon(2);
        return refModule.getLexiconElement(word, object, extend(params, {lexicon: lexicon}));
      }));
      display(word + ':' + object)
      display(speaker1AvgVal)
      display(speaker2AvgVal)      
      csv.writeLine([argv.gameNum, params.alpha, trialNum, 1, object, word, speaker1AvgVal].join(','), outputFile);
      csv.writeLine([argv.gameNum, params.alpha, trialNum, 2, object, word, speaker2AvgVal].join(','), outputFile);
    }, utterances);
  }, objects);
};

var update = function(agentID, dataSoFar) {
  Optimize({
    steps: 50000, verbose: true, optMethod: {adam: {stepSize: 0.0001}},
    model: function() {
      var lexicon = sampleLexicon(agentID);
      mapData({data: dataSoFar, batchSize: _.min([10, dataSoFar.length])}, function(trial) {
        var config = {lexicon: lexicon, context: trial.context};
        if(!params.usingPragmatics){
          var objectToUse = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
          factor(refModule.getLexiconElement(trial.wordID, objectToUse, extend(params,config)));
        } else if(trial.role == 'speaker') {
          factor(refModule.getL0Score(trial.clickedName, trial.wordID, extend(params, config)));
        } else {
          factor(refModule.getSpeakerScore(trial.wordID, trial.intendedName, extend(params, config)));
        }
      });
    }
  });
};

// for each point in data, we want the model's predictions 
var iterate = function(outputFile, remainingTrials, dataSoFar) {
  var currTrialRaw = first(remainingTrials);
  var currTrial = extend(currTrialRaw, {
    context : map(function(v) {return objectLookup[v];},
        [currTrialRaw.object1name, currTrialRaw.object2name,
         currTrialRaw.object3name, currTrialRaw.object4name]),
    intendedName : objectLookup[currTrialRaw['intendedName']]
  });

  console.log('trial data', currTrial);
  console.log('speaker:', currTrial.speakerID)
  // run VI on current data
  //if(!_.isEmpty(dataSoFar[currTrial.speakerID])) {
    console.log('updating')
    update(currTrial.speakerID, dataSoFar[currTrial.speakerID]);
    update(currTrial.listenerID, dataSoFar[currTrial.listenerID]);
//  } 
  
  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, currTrial.speakerID, currTrial.context);

  console.log('speaker output', JSON.stringify(speakerOutput))
  var topSpeakerChoice = sample(speakerOutput)//MAP(speakerOutput)['val'];

  var listenerOutput = L(topSpeakerChoice, currTrial.listenerID, currTrial.context);
  console.log('listener output', JSON.stringify(listenerOutput))
  var topListenerChoice = sample(listenerOutput) // MAP(listenerOutput)['val'];

  display('top speaker choice is ' + topSpeakerChoice);
  display('top listener choice is ' + topListenerChoice);
  display('correct? ' + (topListenerChoice == currTrial.intendedName));
  // if(_.toInteger(currTrial.trialNum) > 1) {
  // display('mu1:word1:obj1: ' + T.get(param({name: 'mu1', dims : lexDims}), 1));
  // display('mu2:word1:obj1: ' + T.get(param({name: 'mu2', dims : lexDims}), 1));
  // }
  csv.writeLine([argv.gameNum, params.alpha, currTrial.trialNum, currTrial.condition,currTrial.contextType,
                 currTrial.speakerID, currTrial.listenerID,
                 currTrial.intendedName,
                 topSpeakerChoice, topListenerChoice,
                 topListenerChoice == currTrial.intendedName
                ].join(','), outputFile);

  var newDataSoFar = _.zipObject([currTrial.speakerID, currTrial.listenerID], map(function(id) {
    return dataSoFar[id].concat(extend(currTrial, {
      role : id == currTrial.speakerID ? 'speaker' : 'listener',
      wordID : topSpeakerChoice,
      clickedName : topListenerChoice
    }));
  }, [currTrial.speakerID, currTrial.listenerID]));

  postTest(currTrial.trialNum, posttestF);
  if(!_.isEmpty(rest(remainingTrials))) {
    iterate(outputFile, rest(remainingTrials), newDataSoFar);
  } 
};

var pragStr = params.usingPragmatics ? 'prag' : 'no_prag';
var f = csv.open('./output/trajectory_' + pragStr + argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,time,condition,contextType,speakerID,listenerID,' +
              'intendedName,topSpeakerChoice,topListenerChoice,correct',
              f);
iterate(f, data, {1: [], 2: []});
csv.close(f);

console.log('running posttest')
postTest('post', posttestF);
csv.close(posttestF);
