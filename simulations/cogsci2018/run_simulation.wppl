// run using, e.g.:
// webppl partnerspecificity.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

var data = refModule.readCSV('input/' + argv.gameNum + '.csv');
var numUtterances = 8;
var utterances = map(function(i) {return 'word' + i;}, _.range(1, numUtterances+1));
var objects = ['circle_striped_highstriped', 'circle_striped_lowstriped',
               'circle_spotted_highspotted', 'circle_spotted_lowspotted',
               'square_red_lightred', 'square_red_darkred',
               'square_blue_lightblue', 'square_blue_darkblue'];
var meanings = ['circle', 'square', 'red', 'blue', 'striped', 'spotted', 
                'highstriped', 'lowstriped', 'lowspotted', 'highspotted', 
                'lightred', 'lightblue', 'darkred', 'darkblue'];
var objectLookup = {
  'redSquare1' : 'square_red_lightred', 'redSquare2' : 'square_red_darkred',
  'blueSquare1' : 'square_blue_lightblue', 'blueSquare2' : 'square_blue_darkblue',
  'stripedCircle1' : 'circle_striped_lowstriped', 'stripedCircle2' :'circle_striped_highstriped',
  'spottedCircle1' : 'circle_spotted_lowspotted', 'spottedCircle2' : 'circle_spotted_highspotted'
};
var numMeanings = meanings.length;
var lexDims = [1];

var params = {
  alpha : 1,
  listenerAlpha: 3,
  coord: argv.coord,
  discountFactor: argv.discountFactor,
  usingPragmatics: argv.usingPragmatics == undefined ? true : argv.usingPragmatics == 'true',
  costWeight: 0,
  utterances: utterances,
  objects: objects
};

var pragStr = (params.usingPragmatics ? 'prag' : 'no_prag') + '_discount' + params.discountFactor + '_' + params.coord;
var posttestF = csv.open('./output/meaningTest_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,agentID,object,word,val', posttestF);

console.log(params);
console.log(lexDims);
var tensorSoftplus = function(x) {
  return T.log(T.add(T.exp(x), 1));
};

var sampleLexicon = function(agentID) {
  var out = _.zipObject(utterances, map(function(utt) {
    return sample(Categorical({vs:meanings}), {guide: function() {
      return Categorical({
        vs: meanings,
        ps: numeric.squishToProbSimplex(param({name: 'categorical_' + agentID + '_' + utt, dims: [numMeanings-1]}))
      });
    }});
  }, utterances));
  return out
};

var S = function(object, context, agentID) {
  return Infer({method: "enumerate"}, function() {
    var utt = uniformDraw(params.utterances);
    var utility = L(utt, context, agentID).score(object);
    display(utt);
    display(utility);
    factor(params.alpha * utility);
    return utt;
  });
};

var L = function(utt, context, agentID) {
  return Infer({method: "enumerate"}, function() {
    var object = uniformDraw(context);
    var utility = expectation(Infer({method: 'forward', guide: true, samples: 5000, model: function() {
      var config = {lexicon: sampleLexicon(agentID), context: context};
      return (params.usingPragmatics ? 
              refModule.getSpeakerScore(utt, object, extend(params, config)) :
	      Math.exp(refModule.getLexiconElement(utt, object, extend(params, config))))
    }}));
    factor(params.listenerAlpha * utility);
    return object;
  });
};

var postTest = function(trial, outputFile) {
    map(function(word) {
      var speaker1TopGuess = JSON.stringify(Infer({method: 'forward', samples: 1000, guide: true}, function() {
        return sampleLexicon(1)[word]
      }));
      var speaker2TopGuess = JSON.stringify(Infer({method: 'forward', samples: 1000, guide: true}, function() {
        return sampleLexicon(2)[word]
      }));
      csv.writeLine([argv.gameNum, params.alpha, trial.trialNum, trial.speakerID, word, speaker1TopGuess].join(','), outputFile);
      csv.writeLine([argv.gameNum, params.alpha, trial.trialNum, trial.listenerID, word, speaker2TopGuess].join(','), outputFile);
    }, utterances);
};

var updatePosterior = function(agentID, dataSoFar) {
  Optimize({
    steps: 10000, verbose: true,optMethod: {adam: {stepSize: 0.005}},
    model: function() {
      var lexicon = sampleLexicon(agentID);
      mapData({data: dataSoFar, batchSize : _.min([20, dataSoFar.length])}, function(trial) { 
        var discount = Math.pow(params.discountFactor,  dataSoFar.length - trial.trialNum);
        var config = {lexicon: lexicon, context: trial.context};
        var objectToUse = params.coord == 'same' ? trial.intendedName : (trial.role == 'speaker' ? trial.clickedName : trial.intendedName);
        if(!params.usingPragmatics){
          factor(refModule.getLexiconElement(trial.wordID, objectToUse, extend(params,config)));
        } else if(trial.role == 'speaker') {
          factor(discount * refModule.getListenerScore(objectToUse, trial.wordID, extend(params, config)));
        } else {
          factor(discount * refModule.getSpeakerScore(trial.wordID, objectToUse, extend(params, config)));
        }
      });
  }});
};

// for each point in data, we want the model's predictions 
var iterate = function(outputFile, remainingTrials, dataSoFar) {
  var currTrialRaw = first(remainingTrials);
  var currTrial = extend(currTrialRaw, {
    context : map(function(v) {return objectLookup[v];},
         [currTrialRaw.object1name, currTrialRaw.object2name,
          currTrialRaw.object3name, currTrialRaw.object4name]),
    intendedName : objectLookup[currTrialRaw['intendedName']]
  });

  console.log('speaker:', currTrial.speakerID)
  // run VI on current data
  updatePosterior(currTrial.speakerID, dataSoFar[currTrial.speakerID]);
  updatePosterior(currTrial.listenerID, dataSoFar[currTrial.listenerID]);
  
  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, currTrial.context, currTrial.speakerID);
  var topSpeakerChoice = MAP(speakerOutput)['val']; // sample(speakerOutput)//

  var listenerOutput = L(topSpeakerChoice, currTrial.context, currTrial.listenerID);
  var topListenerChoice = MAP(listenerOutput)['val']; // sample(listenerOutput)  // 

  display('context is ' + currTrial.context);
  display('top speaker choice is ' + topSpeakerChoice);
  display('top listener choice is ' + topListenerChoice);
  display('intended: ' + currTrial.intendedName);
  display('correct? ' + (topListenerChoice == currTrial.intendedName));
  csv.writeLine([argv.gameNum, params.alpha, params.discountFactor,
                 currTrial.trialNum, currTrial.condition, currTrial.contextType,
                 currTrial.speakerID, currTrial.listenerID,
                 currTrial.intendedName,
                 topSpeakerChoice, topListenerChoice,
                 topListenerChoice == currTrial.intendedName
                ].join(','), outputFile);

  var newDataSoFar = _.zipObject([currTrial.speakerID, currTrial.listenerID], map(function(id) {
    return dataSoFar[id].concat(extend(currTrial, {
      role : id == currTrial.speakerID ? 'speaker' : 'listener',
      wordID : topSpeakerChoice,
      clickedName : topListenerChoice
    }));
  }, [currTrial.speakerID, currTrial.listenerID]));

  postTest(currTrial, posttestF);
  if(!_.isEmpty(rest(remainingTrials))) {
    iterate(outputFile, rest(remainingTrials), newDataSoFar);
  } 
};

var f = csv.open('./output/trajectory_' + pragStr + '_' + argv.gameNum + '.csv');
csv.writeLine('gameNum,alpha,discountFactor,time,condition,contextType,speakerID,listenerID,' +
              'intendedName,topSpeakerChoice,topListenerChoice,correct',
              f);
iterate(f, data, {1: [], 2: []});
csv.close(f);

console.log('running posttest')
postTest('post', posttestF);
csv.close(posttestF);
